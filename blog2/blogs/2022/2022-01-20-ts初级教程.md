---
title: typescript初级教程
date: 2022-01-20
cover: /images/2022-01-20.jpg
tags:
  - typescript
categories:
  - typescript
sticky: 1
---
::: tip 介绍
typescript初级教程
:::
<!-- more -->

# 背景

就在我准备用typescript继续完成我的数据结构与算法的学习时，我发现我对typescript的应用很生涩，并不灵活，我在2021年暑假最后一周学习过尚硅谷的ts教程，不得不说超哥还是牛逼，但还有很多地方没有讲到，

![QQ图片20220120120559](https://gitee.com/yexiyue/picgo-images/raw/master/202201201207743.jpg)

就在前几天，我发现了宝藏，千峰教育新出的typescript教程：[2022前端typescript教程](https://www.bilibili.com/video/BV1H44y157gq?from=search&seid=17827765168222443543&spm_id_from=333.337.0.0)

这是教程内容：![image-20220118185251829](https://gitee.com/yexiyue/picgo-images/raw/master/202201201210701.png)

**相信再学一遍typescript能学到不一样的东西，同时我也很期待陆神的高级教程**

这是高级教程预告内容：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ea4b78575594c74894407a41eab3939~tplv-k3u1fbpfcp-watermark.image?)

**下面是我学习过程的记录**



## 降级编译

将高版本的javascript编译成低版本的



## 严格模式

```json
/* Type Checking */
"strict":true,/* Enable all strict type-checking options.（默认打开所有类型检测） */
"noImplicitAny":true,//implicit含蓄的，隐式的
"strictNullChecks":true
```



## any会禁用ts检查



## 上下文类型

**上下文类型是typescript通过上下文推断类型**

**如果一个函数被确定如何调用的时候会自动推断参数类型**

```typescript
const names=['a','b','c'];
names.forEach((s)=>{
  console.log(s.toUpperCase())
})
```

![image-20220113131644234](https://gitee.com/yexiyue/picgo-images/raw/master/202201131316351.png)





## 对象类型

![image-20220113132104124](https://gitee.com/yexiyue/picgo-images/raw/master/202201131321350.png)



**注意：可以用逗号或分号来分隔**

```typescript
function printCoord(pt:{x:number,y:number}){
  console.log(pt.x)
  console.log(pt.y)
}

printCoord({x:8,y:9})
```



## 可选参数？

**注意：**

**可选：?紧跟变量后面，或?在:前面**

**可能为空：?紧跟可能为空的变量后面，?后面接.方法**（过滤掉underfind或null）

```typescript
function name1(pt:{x:string,y?:string}){
  console.log(pt.x)
  console.log(pt.y?.toUpperCase())
}
name1({x:"sadjh"})
```



## 联合类型(union)

![image-20220113133854925](https://gitee.com/yexiyue/picgo-images/raw/master/202201131338029.png)





## 类型别名（type）

**注意：{}里类型间分隔符可以是逗号、分号或不写**

```typescript
type Point={
  name:string,
  say:(x:string)=>string
}

type name1=string|boolean|number
```



**注意type定义的是一个类型**



## 接口(interface)

![image-20220113141550961](https://gitee.com/yexiyue/picgo-images/raw/master/202201131415108.png)

**注意：接口不能实现接口**



## 类型别名与接口的区别



1. **接口与类型别名很相似，大部分情况下可以混用**
2. **type后面类型接等号**
3. **两次同名interface可以添加新字段（混合）**
4. **type一经声明就不能改变**

### 1.接口实现扩展

```typescript
interface Animal{
  name:string
}

interface Bear extends Animal{
  name:string,
  honey:boolean
}

const bear:Bear={
  name:'红红火火',
  honey:true
}
console.log(bear)
```



### 2.类型别名实现扩展(交叉扩展)

**交叉类型(&)**

```typescript
type Animal={
  name:string
}
type Bear=Animal &{
  honey:boolean
}
const bear:Bear={
  name:'红红火火',
  honey:true
}
console.log(bear)
```



## 类型断言

![image-20220113145733166](https://gitee.com/yexiyue/picgo-images/raw/master/202201131457320.png)



## **未知类型(unknown)**

**当我们不知道这个类型到底是什么的时候可以用unknown**



## 文字类型

```typescript
type name='left'|'center'|'right'|0 |1
```

**注意：本质上就是将确定的值作为类型来约束**



## 叹号断言(!)

```typescript
function abc(x?:number|null){
  //toFixed()去掉小数
  console.log(x!.toFixed())
}

abc(1253.154)
```

**注意：当且仅当知道这个值非空的时候用**

**在需要断言为非空的变量后面加！**





## 枚举

![image-20220113152458162](https://gitee.com/yexiyue/picgo-images/raw/master/202201131524300.png)





## 不太常用的原语

![image-20220113152722207](https://gitee.com/yexiyue/picgo-images/raw/master/202201131527320.png)







# 2.类型缩小

![image-20220113165515227](https://gitee.com/yexiyue/picgo-images/raw/master/202201131655434.png)

**类型防护：特殊的检查**

**类型缩小：将类型细化为比声明更具体的过程**



### 1.typeof 类型守卫

#### [for in 与for of的区别](https://www.cnblogs.com/yanggb/p/11455127.html#:~:text=%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E5%B0%B1%E6%98%AF%EF%BC%8Cfor%20in%E9%81%8D%E5%8E%86%E7%9A%84%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%B3%E9%94%AE%E5%90%8D%EF%BC%89%EF%BC%8C%E8%80%8Cfor,of%E9%81%8D%E5%8E%86%E7%9A%84%E6%98%AF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%80%BC%E3%80%82%20for-in%E6%80%BB%E6%98%AF%E5%BE%97%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84key%E6%88%96%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8B%E6%A0%87%E3%80%82%20for-of%E6%80%BB%E6%98%AF%E5%BE%97%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84value%E6%88%96%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%80%BC%EF%BC%8C%E5%8F%A6%E5%A4%96%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86Map%E5%92%8CSet%E3%80%82)

在JavaScript中遍历数组通常是使用fori循环，自ES5发布后也可以使用forEach，另外在ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，只不过他们的返回结果不一样。但是使用forEach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。

```
myArray.forEach(function (currentValue, index, arr) {
    console.log(currentValue);
});
```

因此另外有for-in循环和for-of循环两种增强型循环。其中，for-in是ES5标准，遍历的是key（可遍历对象、数组或字符串的key）；for-of是ES6标准，遍历的是value（可遍历对象、数组或字符串的value）。



**简单来讲：**

1. **for in 遍历key**
2. **for of 遍历value**



```typescript
function printAll(strs:string | string[] |null){
  if(typeof strs =='object'){
    for(let s of strs!){
      console.log(s)
    }
  }else if(typeof strs =='string'){
    console.log(strs)
  }else{
    console.log(null)
  }
}

printAll(['a','b','c'])
```



### 2.真值缩小

![image-20220114092546843](https://gitee.com/yexiyue/picgo-images/raw/master/202201140925027.png)

**用法：通过以上元素把逻辑从否定分支中过滤掉**

**使用真值进行类型缩小，可以防范underfind和null**

```typescript
function printAll(strs:string | string[] |null){
  //此处通过&&运算排查掉null
  if(strs && typeof strs =='object'){
    for(let s of strs){
      console.log(s)
    }
  }else if(typeof strs =='string'){
    console.log(strs)
  }else{
    console.log(null)
  }
}

printAll(['a','b','c'])

function multiplyAll(values:number[] |undefined,factor:number){
  if(!values){
    return values
  }else{
    return values.map((x)=>{
      return x*factor
    })
  }
}

console.log(multiplyAll([3,4],2))
```



### 3.等值缩小

![image-20220114093849195](https://gitee.com/yexiyue/picgo-images/raw/master/202201140938301.png)



**通过以上操作来缩小类型**

```typescript
function example(x:string |number ,y:string|boolean){
  if(x===y){
    x.toUpperCase()
    y.toUpperCase()
  }else{
    console.log(x)
    console.log(y)
  }
}

interface Container{
  value:number |null |undefined
}

function multiplyValue(container:Container,factor:number){
  if(container.value!=null){
    console.log(container.value)
    container.value *=factor
    console.log(container.value)
  }
}

multiplyValue({value:5},6)
multiplyValue({value:null},6)
```



### 4.in 操作符缩小

![image-20220114095324442](https://gitee.com/yexiyue/picgo-images/raw/master/202201140953583.png)



```typescript
type Fish={swim:()=>void}
type Bird={fly:()=>void}
type Human ={swim?:()=>void,fly:()=>void}
function move(animal:Fish|Bird|Human){
  if("swim" in animal){
    return (animal as Fish).swim()
  }
  return (animal as Bird ).fly()
}
```



### 5.instanceof操作符缩小

```typescript
function logValue(x:Date |string){
  //instanceof判断x是否是Date的实例对象
  if(x instanceof Date){
    console.log(x.toUTCString())
  }else{
    console.log(x.toUpperCase())
  }
}

logValue(new Date())
```



### 6.分配缩小

![image-20220114102140002](https://gitee.com/yexiyue/picgo-images/raw/master/202201141021114.png)

**像以上这种通过分配缩小范围**



## 控制流分析

**return会缩小类型**

![image-20220114104856922](https://gitee.com/yexiyue/picgo-images/raw/master/202201141048080.png)

```typescript
function example(){
  let x:string|number|boolean

  x=Math.random()<0.5

  console.log(x)

  if(Math.random()<0.5){
    x='hello'
    console.log(x)
  }else{
    x=100
    console.log(x)
  }
  return x
}

let x=example()
x='stri'
x=100
x=false
```

![image-20220114110028769](https://gitee.com/yexiyue/picgo-images/raw/master/202201141100834.png)





## 使用类型谓词

![image-20220114110718571](https://gitee.com/yexiyue/picgo-images/raw/master/202201141107705.png)

```typescript
type Fish1={
  name:string,
  swim:()=>void
}

type Bird1={
  name:string,
  fly:()=>void
}

//判断pet类型
function isFish(pet:Fish1|Bird1):pet is Fish1{
  return (pet as Fish1).swim() !=undefined
}

function getSmallPet():Fish1 | Bird1{
  let fish:Fish1={
    name:"sharkey",
    swim:()=>{
      console.log('sharkey')
    }
  }

  let bird:Bird1={
    name:"sparrow",
    fly:()=>{
      console.log('sparrow')
    }
  }

  return Math.random()<0.5?bird:fish;
}


let pet=getSmallPet()

if(isFish(pet)){
  pet.swim()
}else{
  pet.fly()
}

const zoo:(Fish1|Bird1)[]=[getSmallPet(),getSmallPet(),getSmallPet()]

const underWater1:Fish1[]=zoo.filter(isFish)
const underWater2:Fish1[]=zoo.filter(isFish) as Fish1[]

const underWater3:Fish1[]=zoo.filter((pet):pet is Fish1=>{
  if(pet.name=='frog'){
    return false
  }
  return isFish(pet)
})
```



## 受歧视的unions

**在使用unions与可选属性？有诸多不便**

```typescript
interface Circle{
  kind:'circle',
  redius:number,
}

interface Square{
  kind:'square',
  sideLength:number
}

type Shape=Circle|Square
/* function handleShape(shape:Shape){
  if(shape.kind=='square'){

  }

} */

function getArea(shape:Shape){
  switch(shape.kind){
    case 'circle':return Math.PI*shape.redius**2;
    case 'square':return shape.sideLength**2
  }
}

console.log(getArea({kind:"circle",redius:15}))
```



## never类型与穷尽性检查

**注意：never可以分配给每一个类型，但没有任何类型可以分配给never,只有never分配给never**

**因此可以利用这一特性在switch语句中进行穷尽性检查**

```typescript
interface Circle{
  kind:'circle',
  redius:number,
}

interface Square{
  kind:'square',
  sideLength:number
}

interface Trangle{
  kind:'trangle',
  sideLength:number
}

type Shape=Circle|Square|Trangle

function getArea(shape:Shape){
  switch(shape.kind){
    case 'circle':return Math.PI*shape.redius**2;
    case 'square':return shape.sideLength**2;
    default:
      const _exhaustiveCheck:never=shape
      return _exhaustiveCheck;
  }
}

console.log(getArea({kind:"circle",redius:15}))
```



# 3.函数

### 1.调用签名

![image-20220114153829488](https://gitee.com/yexiyue/picgo-images/raw/master/202201141538656.png)

**签名就是函数携带元信息**

**如下所示：我们可以为fn1添加description属性**

**而定义的这种类型就叫签名**

```typescript
//签名
type DescribeFunction = {
  description:string,
  (someArg:number):boolean
}

function doSomething(fn:DescribeFunction){
  console.log(fn.description+' returned '+fn(6))
}

function fn1(n:number){
  console.log(n)
  return true
}

fn1.description='hello'

doSomething(fn1)
```



### 2.构造签名

![image-20220114155019317](https://gitee.com/yexiyue/picgo-images/raw/master/202201141550429.png)

**在调用签名之前加一个new关键字成构造签名**



```typescript
class Ctor{
  constructor(public s:string){}
}

type SomeConstructor={
  // description:string,
  new (s:string): Ctor
}

function fn(ctor:SomeConstructor):Ctor{
  return new ctor('hello')
}

const f=fn(Ctor)
console.log(f.s)


interface CallOrConstructor{
  new (s:string):Date,
  (n?:number):number
}

function fn1(date:CallOrConstructor){
  let d=new date('2021-12-20')
  let n=date(100)
}
```



### **小结**

1. **签名就是对函数的类型之上可以添加额外的属性**
2. **构造签名就是描述构造函数的类型**



# 4.泛型

**泛型：当两个或两个以上值的类型有联系就用泛型**

**在尖括号里的是类型变量，可以有多个**

**后面与该类型有联系的可以直接使用类型变量**



![image-20220114162846307](https://gitee.com/yexiyue/picgo-images/raw/master/202201141628548.png)

```typescript
function map<I,O>(arr:I[],func:(arg:I)=>O):O[]{
  return arr.map(func)
}

const parsed=map(['1','2','3'],(n)=>parseFloat(n))
console.log(parsed)
```



## 1.泛型参数的限制条件



![image-20220114164433545](https://gitee.com/yexiyue/picgo-images/raw/master/202201141644683.png)

**通过继承进行约束**

```typescript
function longest<t extends {length:number}>(a:t,b:t){
  if(a.length>=b.length){
    return a
  }else{
    return b
  }
}

console.log(longest('adfgg','hffgrhhj'))
```



## 2.使用受限制

![image-20220114165319925](https://gitee.com/yexiyue/picgo-images/raw/master/202201141653087.png)



## 3.指定类型参数

```typescript
function combine<t>(arr1:t[],arr2:t[]): t[]{
  return arr1.concat(arr2)
}

const arr=combine<number|string>([1,2,3],['string'])

console.log(arr)
```

**在第二条语句中必须指定联合类型才能使用不同类型数组**



## 4.编写优秀通用函数的准则

![image-20220114172409302](https://gitee.com/yexiyue/picgo-images/raw/master/202201141724471.png)



```typescript
//1.类型参数下推
function firstElement1<t>(arr:t[]){
  return arr[0]
}

function firstElement2<t extends any[]>(arr:t){
  return arr[0]
}

const a=firstElement1([1,2,3])
const b=firstElement2([1,2,3])

//显然第一种更好

function filter1<t>(arr:t[],func:(arg:t)=>boolean){
  return arr.filter(func)
}

function filter2<t,Func extends (arg:t)=>boolean>(arr:t[],func:Func){
  return arr.filter(func)
}
```



## 5.可选参数

![](https://gitee.com/yexiyue/picgo-images/raw/master/202201141742241.png)





# 5.函数重载

![image-20220114175228406](https://gitee.com/yexiyue/picgo-images/raw/master/202201141752555.png)

**注意：**

1. **实现签名与重载签名的参数和返回值都要兼容**
2. **参数只能使用实现签名的参数**
2. **实现签名相当于工具人，对参数类型约束的是重载签名，而实现签名要兼容重载签名**

```typescript
function makeDate(timestamp:number):Date;
function makeDate(m:number,d:number,y:number):Date;
function makeDate(mOrTimestamp:number,d?:number,y?:number):Date{
  if(d!=null && y!=null){
    return new Date(y,mOrTimestamp,d)
  }
  return new Date(mOrTimestamp)
}

const d1=makeDate(52254)
const d2=makeDate(5,6,7)
const d3=makeDate(5,9)
```



![image-20220114180404148](https://gitee.com/yexiyue/picgo-images/raw/master/202201141804266.png)



**注意以下问题会影响重载**

![image-20220114180531407](https://gitee.com/yexiyue/picgo-images/raw/master/202201141805538.png)

```typescript
function fn(x:string):string
function fn(x:boolean):boolean
function fn(x:string|boolean):string|boolean{
  return 'hello'
}
```

## 如何编写好的重载

![image-20220114184625928](https://gitee.com/yexiyue/picgo-images/raw/master/202201141846065.png)





## 函数内的this声明

![image-20220115081050454](https://gitee.com/yexiyue/picgo-images/raw/master/202201150810738.png)

**我的理解：函数内的this声明就是给函数传入一个this参数并指定类型**

**注意：箭头函数没有this参数**

```typescript
interface User{
  admin:boolean
}

interface DB{
  filterUser:(filter:(this:User)=>boolean)=>User[]
}

interface DB1{
  filterUser(filter:(this:User)=>boolean):User[]
}

const db:DB={
  filterUser:(filter:(this:User)=>boolean)=>{
    let user1:User={
      admin:true
    }
    let user2:User={
      admin:true
    }
    return [user1,user2]
  }
}

const adimns=db.filterUser(function(this:User){
  return this.admin
})

console.log(adimns)
```



## 其他类型

![image-20220115083516258](https://gitee.com/yexiyue/picgo-images/raw/master/202201150835493.png)



![image-20220115083605043](https://gitee.com/yexiyue/picgo-images/raw/master/202201150836258.png)



![image-20220115083628817](https://gitee.com/yexiyue/picgo-images/raw/master/202201150836002.png)



![image-20220115083728408](https://gitee.com/yexiyue/picgo-images/raw/master/202201150837586.png)



![image-20220115083753603](https://gitee.com/yexiyue/picgo-images/raw/master/202201150837789.png)



![image-20220115083923559](https://gitee.com/yexiyue/picgo-images/raw/master/202201150839760.png)



## 参数展开运算符

### 1.形参

![image-20220115085149273](https://gitee.com/yexiyue/picgo-images/raw/master/202201150851468.png)



**注意：展开运算符后面的一定是个数组或元组类型**

**因为ES6中展开操作符作用于对象或数组**

```typescript
function multiply(n:number,...m:number[]){
  return m.map(x=>n*x)
}

const ace=multiply(10,1,2,3,4,5)
console.log(ace)
```

![image-20220115090024941](https://gitee.com/yexiyue/picgo-images/raw/master/202201150900038.png)



### 2.实参

![image-20220115090154189](https://gitee.com/yexiyue/picgo-images/raw/master/202201150901360.png)



```typescript
const args=[8,5] as const

const angle=Math.atan2(...args)
```





## 参数结构

![image-20220115091824957](https://gitee.com/yexiyue/picgo-images/raw/master/202201150918123.png)

**在ts中解构需要定义类型**



```typescript
function sum({a,b,c}:{a:number,b:number,c:number}){
  console.log(a,b,c)
}

sum({
  a:10,
  b:3,
  c:9
})
```



## 返回void类型

![image-20220115095047389](https://gitee.com/yexiyue/picgo-images/raw/master/202201150950537.png)

```typescript
type voidFunc=()=>void

const f1:voidFunc=()=>{
  return 'hello'
}

const f2:voidFunc=()=>true

const f3:voidFunc=function(){
  return true
}

const v1=f1()
console.log(v1)//返回hello

function f4():void{
  return true
}

const f5=function():void{
  return true
}
```



![image-20220115100732958](https://gitee.com/yexiyue/picgo-images/raw/master/202201151007162.png)



**理解：声明接口或类型时void可以忽略**

**但在声明函数时声明void则不能返回任何值**



# 6.对象类型

![image-20220115101752893](https://gitee.com/yexiyue/picgo-images/raw/master/202201151017022.png)



```typescript
//1.匿名对象
function greet(person:{name:string,age:number}){
  return 'hello'+''+person.name;
}

//2.接口命名
interface IPerson{
  name:string,
  age:number
}

function greet1(person:IPerson):string{
  return 'hello'+person.name
}

//3.类型别名
type Person={
  name:string,
  age:number
}

function greet2(person:Person):string{
  return 'hello'+person.name
}
```



## 1.属性修改器



### 1.可选属性

**注意：ES6解构语法与ts类型注释相冲突，注意不要在解构时加类型注释**



```typescript
type Shape1={}

interface PaintOptions{
  shape:Shape1,
  xPos?:number,
  yPos?:number
}

/* function paintShape(opts:PaintOptions){
  let xPos=opts.xPos
  let yPos=opts.yPos
  console.log(xPos)
  console.log(yPos)
} */

/* function paintShape(opts:PaintOptions){
  let xPos=opts.xPos==undefined?0:opts.xPos
  let yPos=opts.yPos==undefined?0:opts.yPos
  console.log(xPos)
  console.log(yPos)
} */

//ES6解构语法与ts类型注释相冲突，注意不要在解构时加类型注释
function paintShape({shape:Shape,xPos:number=0,yPos=0}:PaintOptions){
  /* let xPos=opts.xPos==undefined?0:opts.xPos
  let yPos=opts.yPos==undefined?0:opts.yPos */

  console.log(shape)
  console.log(number)
}


const shape:Shape1={}

paintShape({shape:shape,xPos:20,yPos:30})
```



### 2.只读属性(readonly)

```typescript
import { isConstructorDeclaration } from "typescript"

interface SomeType{
  //通过readonly关键字设置只读属性
  readonly prop:string
}

function doSomething(obj:SomeType){
  console.log(obj.prop)
  // obj.prop='hello'
}

interface Home{
  readonly resident:{
    name:string,
    age:number
  }
}

function visitForBirthday( home:Home){
  console.log(home.resident.name)
  home.resident.age++
}

function evict(home:Home){
  /* home.resident={
    name:"fgsdy",
    age:18
  } */
}

interface Person{
  name:string,
  age:number
}

interface ReadonlyPerson{
  readonly name:string,
  readonly age:number
}

let writeablePerson:Person={
  name:"Felix",
  age:18
}

let readonlyPerson:ReadonlyPerson=writeablePerson


console.log(readonlyPerson.age)
writeablePerson.age++;
// readonlyPerson.age++;
console.log(readonlyPerson.age)
```



**注意：readonly只作用最外层**

**可写属性也可以分配给可读属性，通过修改可写属性来改变可读属性**



### 3.索引签名

**用法：`[index:number]:string`类似的叫索引签名**

**方括号里面的是索引，名称任取，类型可以定义**

```typescript
interface StringArray{
  [index:number]:string
}

const myArray:StringArray=['a','b']

const secondItem=myArray[0]

interface TestString{
  [props:string]:number
}

let testString:TestString={
  x:200,
  y:200,
  aaa:16
}

interface Animal1{
  name:string
}

interface Dog extends Animal1{
  breed:string
}

interface NotOkay{
  [index:string]:number|string,
  length:number,
  name:string
}

let notOkay:NotOkay={
  x:100,
  length:100,
  name:'flex',
  age:12
}

interface myTest{
  name:string,
  age:number,
  readonly [protos:string]:number|string
}

let acee:myTest={
  name:'gdfa',
  age:18,
  sex:'nan',
  hobby:6
}
// acee.hobby=14
```



## 2.扩展类型

**本质上是类型的之间的继承，继承多个类型中间用逗号隔开**

```typescript
interface Colorful1{
  color:string
}

interface Circle3{
  radius:number
}

interface ColorCircle extends Colorful1,Circle3{}

const cc:ColorCircle={
  color: 'red',
  radius: 48,
}
```



## 3.交叉类型

![image-20220115161312085](https://gitee.com/yexiyue/picgo-images/raw/master/202201151613218.png)

**主要用于组合现有的对象类型**

**使用&叠加两个或多个对象类型**

```typescript
interface Colorful{
  color:string
}

interface Circle2{
  radius:number
}

interface Square2{
  sideLength:number
}
type ColorfulCircle2=Colorful&Circle2&Square2

let abc1:ColorfulCircle2={
  color:'red',
  radius:265,
  sideLength:484
}
```

**注意：交叉类型是强制性的，两个或多个对象里的属性一个都不能少**

**联合类型就很随意**



## 交叉类型与接口继承(类型扩展)的区别

```typescript
interface Sister{
  name:string
}

interface Sister{
  age:number
}

const sister1:Sister={
  name:'sisterAn',
  age:18
}

type Sister2={
  name:string
}

type Sister2={
  
}
```

![image-20220115171243290](https://gitee.com/yexiyue/picgo-images/raw/master/202201151712353.png)



### 小结

**类型合并用interface**

**类型避免重复用type**



## 4.泛型对象类型

![image-20220115183735253](https://gitee.com/yexiyue/picgo-images/raw/master/202201151837409.png)



```typescript
interface Box{
  contents:unknown
}

let x1:Box={
  contents:'hello world'
}

//进行类型缩小，缩小到具体的类型才能对unknown类型进行操作
//因为对unknown类型进行任何操作都不合法
//1.类型缩小
if(typeof x1.contents=='string'){
  console.log(x1.contents.toLowerCase())
}

//2.类型断言
console.log((x1.contents as string).toUpperCase())


//通过函数重载实现
//安全但不优雅
interface NumberBox{
  contents:number
}
interface StringBox{
  contents:string
}
interface BooleanBox{
  contents:boolean
}

function setContents(box:NumberBox,newContents:number):void;
function setContents(box:StringBox,newContents:string):void;
function setContents(box:BooleanBox,newContents:boolean):void;
function setContents(box:{contents:string|boolean|number},newContents:number|boolean|string){
  box.contents=newContents
}

interface Box1<t>{
  contents:t
}

let boxA:Box1<string>={
  contents:'hello'
}

type Box2<t>={
  contents:t
}

//定义通用辅助类型
type OrNull<T>=T | null

type OneOrMany<T>=T | T[]

type OneOrManyOrNull<T>=OrNull<OneOrMany<T>>

type OneOrManyOrNullOrString=OneOrManyOrNull<string>

```



**泛型系统很强大，可以通过它来达到更灵活的目的**

**也可以定义通用的类型**



# 7.类型操作

## 1.从类型中创建类型

![image-20220116111225159](https://gitee.com/yexiyue/picgo-images/raw/master/202201161112334.png)





### 1.泛型

![image-20220116111834258](https://gitee.com/yexiyue/picgo-images/raw/master/202201161118436.png)



**定义：能够创建在各种类型上工作的组件而不是单一的类型就是泛型，其中在尖括号中定义类型变量，后面可以直接使用类型变量**



#### 使用通用类型变量

```typescript
//类型约束
/* function logggingIdentity<Type extends {length:number}>(arg:Type):Type{
  console.log(arg.length)
  return arg
} */
//使用泛型类型变量
function logggingIdentity<Type>(arg:Type[]):Type[]{
  console.log(arg.length)
  return arg
}

console.log(logggingIdentity<string>(['a','b','c']))
```



#### 泛型类型(泛型接口)

![image-20220116114354132](https://gitee.com/yexiyue/picgo-images/raw/master/202201161143245.png)



```typescript
function identity<Type>(arg:Type):Type{
  return arg
}

// let myIdentity:<Type>(a:Type)=>Type=identity

//函数也是一种对象
let myIdentity:{<T>(arg:T):T}=identity

interface GenericIdentityFn{
  // name:string
  <T>(arg:T):T
}

//在前头函数括号前面声明类型变量
let anb:GenericIdentityFn=<t>(arg:t):t=>{
  return arg
}

anb<string>('fgsdyf')


//正宗的泛型接口
interface GenerticIdentity<Type>{
  (arg:Type):Type
}

let a1:GenerticIdentity<string>=identity

a1('fbdhg')
```



**小结：**

1. **函数也是一种对象，因此签名与函数类型相等**
2. **在前头函数括号前面声明变量类型**
3. **用正宗的泛型接口更符合规范**



#### 泛型类

![image-20220116120137969](https://gitee.com/yexiyue/picgo-images/raw/master/202201161201096.png)



```typescript
class GenericNumber<NumType>{
  zeroValue:NumType;
  constructor(zeroValue:NumType){
    this.zeroValue=zeroValue
  }
  add(x:NumType,y:NumType):NumType{
    return Math.random()<0.5?x:y;
  }
  //没有初始化
  //类里面声明方法不能用function关键字
  /* add:(x:number,y:number)=>number */

}

let myGeneric=new GenericNumber(123)
myGeneric.add=(x,y)=>{
  return x+y
}
console.log(myGeneric.add(9,10))
```



**小结：**

1. **类里面声明方法不能用function关键字**
2. **所有值都尽可能初始化**
3. **方法可以重写**



#### 泛型约束

![image-20220116124530574](https://gitee.com/yexiyue/picgo-images/raw/master/202201161245683.png)

```typescript
//类型约束
function logggingIdentity<Type extends {length:number}>(arg:Type):Type{
  console.log(arg.length)
  return arg
}
```





#### 在泛型约束中使用类型参数



```typescript
function getProperty<Type,Key extends keyof Type>(obj:Type,key:Key):void{
  console.log(obj[key])
}

let x3={
  a:1,
  b:2,
  c:3,
  d:4
}

getProperty(x3,'a')
getProperty(x3,'b')
getProperty(x3,'c')
getProperty(x3,'e')


```

![image-20220116125726465](https://gitee.com/yexiyue/picgo-images/raw/master/202201161257533.png)



#### 在泛型中使用类类型

![image-20220116125957683](https://gitee.com/yexiyue/picgo-images/raw/master/202201161259811.png)



```typescript
function create<Type>(c:new ()=>Type):Type{
  return new c()
}

function create1<Type>(c:{new ():Type}):Type{
  return new c()
}

class BeeKeeper{
  hasMask:boolean=true
}

class ZooKeeper{
  nametag:string='Mikle'
}

class Animal2{
  numLegs:number=4
  say():void{
    console.log(this)
  }
}

class Bee extends Animal2{
  keeper:BeeKeeper=new BeeKeeper()
}

class Lion extends Animal2{
  keeper:ZooKeeper=new ZooKeeper()
}

function createInstance<A extends Animal2>(c:new ()=>A):A{
  return new c()
}
console.log(createInstance(Lion).keeper.nametag);
// createInstance(ZooKeeper)
createInstance(Bee).say()


```

![image-20220116133014969](https://gitee.com/yexiyue/picgo-images/raw/master/202201161330053.png)



#### **小结：构造签名可以接收类**

例子：

```
interface IClass<t>{
  new ():t
}

class Animal3{
  name:string='路废'
}

function create2<t>(c:IClass<t>):t{
  return new c()
}

console.log(create2(Animal3));

```



## 2.keyof类型操作符

**keyof类型操作符可以接受一个对象类型，会产生key的字符串或者是数字字面量的一个集合（联合类型）**

![image-20220116160310490](https://gitee.com/yexiyue/picgo-images/raw/master/202201161603703.png)



```typescript
type Point1={
  x:number,
  y:number
}

type P=keyof Point1
//返回联合类型 'x'|'y'
let x4:P='x'
let x5:P='y'


type Arrayish={
  [n:number]:number
}

let a2:Arrayish=[1,2,3,4]
//返回number类型的索引
type Arr1=keyof Arrayish

let a3:Arr1=1

type Mapish={
  [K:string]:number
}
//返回联合类型string|number类型的索引
type M=keyof Mapish

let m:M=1223
m='5245'
```



**小结**

1. **如果索引签名的[]里定义number类型，则keyof操作符只能取到number类型**
2. **如果索引签名的[]里定义string类型，则keyof操作符取到number|string联合类型**



**注意：这是类型操作符，只对类型编程有效**



## 3.typeof类型操作符

**typeof可以在类型上下文中引用一个变量或者是属性的类型**

![image-20220116162509387](https://gitee.com/yexiyue/picgo-images/raw/master/202201161625485.png)



**注意：**

1. **typeof 后面接变量时是类型守卫和熟悉的JavaScript一样返回该变量的类型**
2. **typeof 后面接类型时是类型操作符表引用**



```typescript
type abc=string
let a6:abc='hello'

//报错信息：
//'abc' only refers to a type, but is being used as a value here.
//这里犯了致命错误typeof是类型操作符
console.log(typeof abc)

if(typeof a6=='string'){
  console.log(111)
}
console.log(typeof a6)
```

```typescript
let s='hello world'
let n:typeof s ='hello'
n=100
```

![image-20220116163505660](https://gitee.com/yexiyue/picgo-images/raw/master/202201161635790.png)



```typescript
//ReturnType<T> 这是ts预定义的类型，T必须传入一个函数的类型，返回的是函数返回值的类型

type Predicate=(x:unknown)=>boolean
type K=ReturnType<Predicate>
let a6:K=true

function f4(){
  return {
    x:10,
    y:3
  }
}

type P4=ReturnType<typeof f4>

function msgbox(){}
let shouldContinue:typeof msgbox
shouldContinue=100
```

![image-20220116165453577](https://gitee.com/yexiyue/picgo-images/raw/master/202201161654652.png)



**小结：**

1. **typeof将值与类型联系起来了**
2. **但typeof后面不能调用函数**
3. **如果想要返回函数返回值的类型用typescript预定义的`ReturnType<T>`**
4. **`ReturnType<T>` 这是ts预定义的类型，T必须传入一个函数的类型，返回的是函数返回值的类型**



## 4.索引访问类型

**可以使用索引访问类型去查询另外一个类型上的特定属性**



![image-20220116165422111](https://gitee.com/yexiyue/picgo-images/raw/master/202201161654250.png)



```typescript
/* type Person1={
  age:number,
  name:string,
  alive:boolean
}

//类似于对象取值，但这里取的是类型
type Age=Person1['age']

let age:Age='445' */

interface Person1{
  name:string,
  age:number,
  alive:boolean
}

//在方括号里也能用联合类型的方式
//这里I1的类型是string|number联合类型
type I1=Person1['age'|'name']
let i1:I1='hello'
let i2:I1=1234
// let i3:I1=true

//妙啊，将对象里各个属性的类型联合起来
type I2=Person1[keyof Person1]
const i21:I2='hello'

type AliveOrName='alive' | 'name';
type I3=Person1[AliveOrName]
let i3:I3=true
i3='hello'
// i3=100

const MyArray:{name:string,age:number}[]=[
  {name:'Alice',age:15},
  {name:'Bob',age:23},
  {name:'Eve',age:29},
]

//注意点这里number表示任意一个元素
type Person2=typeof MyArray[number]

const p:Person2={
  name:"hello",
  age:16
}

type Age=typeof MyArray[number]['age']
const age:Age=11


```



**小结：**

1. **类似于对象或数组取值，但这里取的是类型**
2. **在方括号里也能使用用联合类型的方式，keyof，typeof**
3. **注意一下`typeof MyArray[number]`**



### **感悟：值是值，类型是类型**



## 5.条件类型

![image-20220116172732544](https://gitee.com/yexiyue/picgo-images/raw/master/202201161727665.png)

**简单示例：**

```typescript
interface Animal4{
  live():void
}

interface Dog extends Animal4{
  woof():void
}

type Example1 = Dog extends Animal4 ?number:string;
let b1:Example1=123
```



**核弹：**

```typescript
interface IdLabel {
  id: number
}
interface NameLabel {
  name: string
}

/* function createLabel(id:number):IdLabel
function createLabel(name:string):NameLabel
function createLabel(nameOrId:string|number):IdLabel|NameLabel
function createLabel(nameOrId:string|number):IdLabel|NameLabel{
  return {
    id:123,
    name:'hello'
  }
}
 */

type NameOrId<T extends number | string> = T extends number ? IdLabel : NameLabel;

function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
  /*   let a:IdLabel={
      id:1234
    }
    let b:NameLabel={
      name:"hello"
    } */
  throw '你好，我的世界'
}

let a7 = createLabel('typescript')
/* console.log(a7) */

```

## 6.条件类型约束

![image-20220116180631301](https://gitee.com/yexiyue/picgo-images/raw/master/202201161806411.png)

```typescript
type MessageOf<T>=T['message']
```

![image-20220116180848429](https://gitee.com/yexiyue/picgo-images/raw/master/202201161808506.png)



```typescript
// type MessageOf<T>=T['message']

// type MessageOf<T extends {message:unknown}>=T['message']

//核心代码
type MessageOf<T>=T extends {message:unknown}?T['message']:never

interface Email{
  message:string
}

interface Dog{
  bark():void
}

type EmailMessageContents=MessageOf<Email>
let a8:EmailMessageContents='hello'

type DogMessageContents=MessageOf<Dog>
let a9:DogMessageContents='hello'

type Flatten<T>=T extends any[]?T[number]:T

//type Str=string
type Str=Flatten<string[]>

//type Num=number
type Num=Flatten<number>

```

![image-20220116182154136](https://gitee.com/yexiyue/picgo-images/raw/master/202201161821202.png)





## 7.在条件类型内推理(infer关键字)

![image-20220117084233323](https://gitee.com/yexiyue/picgo-images/raw/master/202201170842467.png)



```typescript
type GetReturnType<Type>=Type extends (...args:never[])=>infer Return ? Return : never

//type Num1=number
type Num1 =GetReturnType<()=>number>
let num:Num1=123

//infer英文意思是推断，在上面例子中Return是从函数中推倒出来的
type Bools=GetReturnType<(a:boolean,b:boolean)=>number[]>
let bools:Bools=[1,2,3]

//如果是重载函数，从最后一个签名推断
function stringOrNum(x:string):number
function stringOrNum(x:number):string
function stringOrNum(x:string|number):string|number{
  return 'hello'
}

//type T1=string
type T1=ReturnType<typeof stringOrNum>
const t1:T1='hello'

type GetObjType<T>=T extends {length:infer R} ? R :never
interface P1{
  name:string,
  length:string
}

//type Test=string
type Test=GetObjType<P1>
let c1:Test='hello'
```



**小结：**

1. **infer英文意思是推断，在上面例子中Return是从函数中推倒出来的**
2. **infer也用于声明类型变量，不过这不需要指定，而是自动推断出来的**



## 8.分布式条件类型

**当条件类型作用于一个通用类型的时候，给定它一个联合类型，那它就变成一个分布式条件类型**



**作一个分布式的分发**

![image-20220117101206687](https://gitee.com/yexiyue/picgo-images/raw/master/202201171012815.png)



```typescript
type ToArray<Type> = Type extends any ? Type[] : never

//type StrArrOrNumArr = string[] | nmuber[]
type StrArrOrNumArr = ToArray<string | number>

let saon1: StrArrOrNumArr = ['hello']
saon1 = [1, 2, 3]

//非分发式的,定义非分布式的在使用类型变量时加[]
type ToArray1<T> = [T] extends [any] ? T[] : never

//type StrArrAndNumArr=(string|number)[]
type StrArrAndNumArr=ToArray1<string|number>
let saon2:StrArrAndNumArr=[123,'hello']
```



**小结：**

**类型操作很重要，还有很多东西值得深究**





# 8.类



## 1.类成员

![image-20220117103249184](https://gitee.com/yexiyue/picgo-images/raw/master/202201171032349.png)





### 1.类属性

![image-20220117103648172](https://gitee.com/yexiyue/picgo-images/raw/master/202201171036340.png)



### 2.readonly

**作用：防止在构造函数之外进行赋值**

![image-20220117104614950](https://gitee.com/yexiyue/picgo-images/raw/master/202201171046101.png)



### 3.构造器

![image-20220117110237199](https://gitee.com/yexiyue/picgo-images/raw/master/202201171102420.png)



### 4.方法

**一个类中的函数属性就叫方法**

![image-20220117110620126](https://gitee.com/yexiyue/picgo-images/raw/master/202201171106394.png)



### 5.Getters/Setters

**Getters/Setters是类里面特殊的方法，称之为访问器**

**Getters/Setters也是存取器**

![image-20220117111459953](https://gitee.com/yexiyue/picgo-images/raw/master/202201171115194.png)

```typescript
class D{
  private _name:string
  constructor(name:string){
    this._name=name
  }

  get name(){
    return this._name+'你好'
  }

  set name(value:string){
    this._name=value
  }
}

let d3:D=new D('世界')
console.log(d3.name)
```





### 6.索引签名

**注意：索引签名一旦定义好，类里面的属性或方法就要受到约束**

![image-20220117115355967](https://gitee.com/yexiyue/picgo-images/raw/master/202201171153213.png)

```typescript
class MyClass{
  [s:string]:boolean|((s:string)=>boolean)
  x:number=100
  say(s:string):boolean{
    return typeof s =='string'
  }
}
```

![image-20220117115716185](https://gitee.com/yexiyue/picgo-images/raw/master/202201171157267.png)





## 2.类继承

### 1.implements子句

![image-20220117131638772](https://gitee.com/yexiyue/picgo-images/raw/master/202201171316031.png)



**注意：**

1. **implements只是起检查作用并不会改变类的类型或方法**
2. **类里面的实现但必须要与接口兼容**
3. **可选属性如果实现了就能存在，不实现就没有**

```typescript
interface Checkable{
  check(name:string):boolean
}

class NameChecker implements Checkable{
  check(name: number |string): boolean {
    return true
  }
}
```





### 2.extends子句

![image-20220117134230905](https://gitee.com/yexiyue/picgo-images/raw/master/202201171342907.png)





### 注意：super可以访问父类的属性和方法





### 3.方法重写

![image-20220117135329345](https://gitee.com/yexiyue/picgo-images/raw/master/202201171353590.png)



**注意：**

**子类重写方法要与父类兼容**



```typescript
class Base{
  greet(){
    console.log('hello world')
  }
}

class Derived extends Base{
  greet(name?:string): void {
    if(name==undefined){
      super.greet()
    }else{
      console.log(name.toUpperCase())
    }
  }
}

const d=new Derived()
d.greet()
d.greet('reader')
```





## 3.初始化顺序

![image-20220117141327927](https://gitee.com/yexiyue/picgo-images/raw/master/202201171413176.png)

**注意：**

1. **基类就是父类**
2. **派生类就是子类**



**小结：**

1. **先是基类字段和构造函数初始化**
2. **再是派生类字段和构造函数初始化**



## 4.继承内置类型

```typescript
class MsgError extends Error{
  constructor(m:string){
    super(m)
    //明确的设置原型
    Object.setPrototypeOf(this,MsgError.prototype)
  }
  sayHello(){
    return 'hello '+this.message
  }
}

const msgError=new MsgError('世界')

console.log(msgError.sayHello())

console.log(msgError instanceof MsgError)
```



**注意：**

**在ES5及以下版本要明确设置原型**



## 5.成员的可见性

![image-20220117180816161](https://gitee.com/yexiyue/picgo-images/raw/master/202201171808431.png)



### 1.public

![image-20220117181414366](https://gitee.com/yexiyue/picgo-images/raw/master/202201171814545.png)



**public公共的**

**在当前类、子类、实例上都能访问**



### 2.protected

![image-20220117182014860](https://gitee.com/yexiyue/picgo-images/raw/master/202201171820048.png)



**protected受保护的**

1. **只能在当前类和子类中访问**
2. **在实例中不能访问**
3. **子类可以暴露父类的受保护的方法和属性**



```typescript
//子类可以暴露父类的受保护的方法和属性
class Base2 {
  protected m=10
}

class Derived2 extends Base2{
  public m=15
}

const d4=new Derived2()

console.log(d4.m)
```



### 3.private

![image-20220118101826240](https://gitee.com/yexiyue/picgo-images/raw/master/202201181018416.png)

**private**

1. **只允许当前类访问**
2. **子类和实例都不行**
3. **可以借助方法来访问私有属性**

```typescript
//跨实例的私有访问
class A{
  constructor(private x:number){}

  public sameAs(other:A){
    return other.x
  }
}

let e1:A=new A(20)

let e2:A=new A(15)

console.log(e1.sameAs(e2))
```



**我们可以通过定义方法来跨实例访问私有属性**





## 6.类的静态成员

![](https://gitee.com/yexiyue/picgo-images/raw/master/202201181040464.png)

**类的静态成员在属性或方法前面加`static`，我们不需要实例化直接通过类名字就能访问属性和方法**

**静态成员跟普通成员一样**

1. **能被public、private、protected修饰**
2. **能被继承**



## 7.static区块

![image-20220118105507924](https://gitee.com/yexiyue/picgo-images/raw/master/202201181055155.png)



**在static修饰的属性或方法前面加#就会变成私有的**

```typescript
class Foo{
  static #count=0

  static #say(){
    console.log(Foo.#count)
  }
  get count(){
    return Foo.#count
  }

  //static区块,可以访问static #开头的静态成员
  //static区块在类创建的时候就会被执行
  static {
    try {
      const lastInstatnce={
        length:100
      }
      Foo.#count+=lastInstatnce.length
      Foo.#say()
    } catch (error) {
      
    }
  }
}

let f6=new Foo()
console.log(f6.count)

```



**小结：**

1. **static区块,可以访问static #开头的静态成员**
2. **static区块在类创建的时候就会被执行**



## 8.泛型类

![image-20220118110841642](https://gitee.com/yexiyue/picgo-images/raw/master/202201181108827.png)



**注意：静态成员不能使用泛型**





## **9.类运行时中的this**



![image-20220118111805660](https://gitee.com/yexiyue/picgo-images/raw/master/202201181118911.png)



**箭头函数**

1. **浪费更多的内存**
2. **不能在派生类中使用super.getName调用即不能在子类里通过super调用父类的方法了**



## 10.this类型

![image-20220118114808080](https://gitee.com/yexiyue/picgo-images/raw/master/202201181148264.png)



```typescript
/* class Box{
  constent:string=''

  set(value:string){
    this.constent=value
    return this
  }
}

class ClearableBox extends Box{
  clear(){
    this.constent=''
  }
}

const h=new ClearableBox()
const i=h.set('hello')

console.log(i) */

class Box{
  conten:string=''

  sameAs(other:this){
    return other.conten==this.conten
  }
}

class DerivedBox extends Box{
  otherContent:string=''
}

const baseBox=new Box()
const derived=new DerivedBox()

derived.sameAs(baseBox)


```

![image-20220118121116731](https://gitee.com/yexiyue/picgo-images/raw/master/202201181211797.png)



**上面例子中将this作为类型进行约束**

**在Box基类中定义sameAs(other:this)方法，这里this是动态的谁调用this就指向谁**

**`derived.sameAs(baseBox)`在执行该语句时this已经动态指向了DerivedBox的实例**

**而baseBox是Box类型所以ts会提示错误信息**



## 11.基于类型守卫的this

![image-20220118121851276](https://gitee.com/yexiyue/picgo-images/raw/master/202201181218397.png)



在类和接口的方法的返回位置使用**this is** Type语法，**this is 是固定的**

**结合if语句可以进行类型缩小**



```typescript
class FileSystemObject{
  isFile():this is FileRep{
    return this instanceof FileRep
  }

  isDirectory():this is Directory{
    return this instanceof Directory
  }

  isNetworked():this is Networked & this{
    return this.networked
  }

  constructor(public path:string,private networked:boolean){}
}

class FileRep extends FileSystemObject{
  constructor(path:string,public content:string){
    super(path,false)
  }
}

class Directory extends FileSystemObject{
  children:FileSystemObject[]
  constructor(){
    super('',false)
    this.children=[]
  }
}

interface Networked{
  host:string
}

const fso:FileSystemObject=new FileRep('foo/bar.txt','foo')
if(fso.isFile()){
  fso.content
}else if(fso.isDirectory()){
  fso.children
}else if(fso.isNetworked()){
  fso.host
}

class Box5<T>{
  value?:T

  hasValue():this is {value:T}{
    return this.value!=undefined
  }
}

const box=new Box5<string>()

box.value='hello'

if(box.hasValue()){
  console.log(box.value.toUpperCase())
}
```



## 12.参数属性

![image-20220118143901123](https://gitee.com/yexiyue/picgo-images/raw/master/202201181439300.png)

**注意：参数属性前面一定要写修饰符，不然会当作普通参数**



## 13.类表达式

![image-20220118144627634](https://gitee.com/yexiyue/picgo-images/raw/master/202201181446848.png)

```typescript
const someClass=class<T>{
  constructor(public value:T){}
}

const m3=new someClass('hello world')
console.log(m3.value)
```



**类表达式也称匿名类**

`const m3:someClass=new someClass('hello world')`

**注意：匿名类不能写类型注释**



## 14.抽象类和成员

![image-20220118150016525](https://gitee.com/yexiyue/picgo-images/raw/master/202201181500737.png)



**抽象类不能实例化，只能作为基类被继承**

```typescript
abstract class Base3{
  abstract getName():string;

  printName(){
    console.log(this.getName())
  }
}

class Derived3 extends Base3{
  getName(): string {
    return 'world'
  }
}


/* function greet(ctor:typeof Base3){
  const instance=new ctor()
} */

//抽象构造签名
function greet(ctor:new ()=>Base3){
  const instance=new ctor()
  instance.printName()
}

// greet(Base3)

greet(Derived3)

```



**若想要使用抽象类型，则需定义构造签名**



## 15.类之间的关系

![image-20220118151515718](https://gitee.com/yexiyue/picgo-images/raw/master/202201181515881.png)





# 9.模块

## 1.ES模块语法

![image-20220118152207066](https://gitee.com/yexiyue/picgo-images/raw/master/202201181522285.png)

![image-20220118152741883](https://gitee.com/yexiyue/picgo-images/raw/master/202201181527017.png)





## 2.Typescript特定的ES模块语法

![image-20220118183743827](https://gitee.com/yexiyue/picgo-images/raw/master/202201181837038.png)







